
swig2bmx: a SWIG "backend" to generate BlitzMax wrapper code
============================================================

This hacked-together mess of scripts is designed to provide a starting point
for wrapping C and C++ libraries to use with BlitzMax. 99% of the wrapper code
can be automatically generated by SWIG and cffi2bmx, leaving only minor tweaks
to fill in by hand.

The resulting wrapper will not be quite as fast or as elegant as a hand-crafted
solution, but it's much easier than wrapping tens or hundreds of thousands of
lines of code manually, right?


Status:
-------

Working. swig2bmx is capable of generating a working wrapper for the latest
release of Irrlicht (1.8.1 at last update), a practical and useful example.

The pipeline is NOT CURRENTLY AUTOMATED: the "script" is currently a series of
instructions for a human operator to follow. Changing this will be the first
priority.


Requirements:
-------------

SWIG 3, GCC-compatible C++ compiler, Gambit Scheme, BlitzMax, standard *nix
shell environment (or MSYS)


Automation level:
-----------------

Wrapping Irrlicht (50MB) requires approximately 8KB of hand-written code (which
includes script and .i files, not completely separated atm). This is a far
better code ratio than previous efforts. 100% of Irrlicht functionality is
exposed (with some problems) and memory is managed automatically.


Basic technique:
----------------

All values are divided into one of two categories: primitive number, or object
reference. This is the model used by BlitzMax and most high-level languages.
All C++ objects are represented as pointers held in BlitzMax proxy objects; the
proxy also contains a per-object finalizer that can free the object, do nothing,
or take some custom action (such as decrementing a refcount). This is used to
allow writing code similar to C++ where stack-allocated or RAII objects are
placed inline in expressions without needing to be freed explicitly.


Limitations:
------------

Templates: templates are not made available to the library user. BlitzMax offers
no support, and SWIG doesn't export them (since it creates a C-like interface).
It should be possible to instantiate all templates in advance (e.g. with a
typedef declaration) that the user expects to use. Complicated TMP or inline
template expressions are not suitable for SWIG.

Parameters of an unrecognised template type are currently exported as Byte Ptr.


Multiple inheritance: BlitzMax does not support multiple inheritance and SWIG
will only export one superclass per class. You may want to change the one it
picks (I think it tends to choose badly), e.g. IEventReceiver -> ISceneNode for
ICameraSceneNode.

Inheritance isn't a showstopper, as casting to another proxy type is very easy.
As long as it's a legitimate end type (it will *always* succeed, so be careful),
the methods on the proxy object will still work.


Operators: basic operator overloading is supported, translating operators into
methods named "Add", "Mul", etc. This will do for simple things (e.g. adding
vectors or matrices), but complicated operators - such as && - are not exported.
A library that relies on bizarre and complex overloads to create a domain
specific sublanguage (e.g. Boost::Phoenix, Spirit) is totally unsuitable for
wrapping.


Overloading: Since BlitzMax does not support overloading, overloaded methods are
renamed. The wrapper makes two attempts to rename methods, by adding parameter
names, and then if that fails by adding their types instead; if both result in
a method that would clash with an existing export, the method is omitted.

In practice over 99% of methods can be exported in this way, although some of
their names may be a bit unpredictable.


Global variables: are exported as read-only via wrapper function. In practice
you don't generally need to set globals in a library directly, so this is not
a big deal.


Customization:
--------------

There are four places to add functionality to the wrapper.

To add features to the SWIG backend, create a file called
<lib>-method-advice.scm (e.g. "irrlicht-method-advice.scm"), and redefine any of
the following functions:

(before-method-advice c n a)
(var-call-advice arg n)
(after-method-advice m)
(return-special-advice c n r)
(return-object-advice c n r)
(interface-typemap t)

These can insert special behaviour for values of types that don't quite fit the
value/proxy object model. With Irrlicht these are used to let library functions
accept BlitzMax strings instead of char* strings.

To add extra BMX code to the library, create a file called <lib>-helper.bmx
(e.g. "irrlicht-helper.bmx"). It will be Included automatically. You can use it
to e.g. add conversion functions from Max data types that the C++ library
wouldn't be expecting.

To add any extra C++/machine code to the library, create a file called
<lib>.help-wrap.o (e.g. "irrlicht.help-wrap.o"). This will be Imported if it
exists. Irrlicht needs this to expose some C functions to Max.

Note that these filenames are case-sensitive.

You can make cffi-to-bmx aware of extra data types by giving them their own
typemaps in the .i file. This is handled as normal for SWIG.


Happy wrapping!


